
<title>Web NFC GUI</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    font-family: Arial, sans-serif;
  }

  button {
    padding: 10px 20px;
    margin: 10px;
    font-size: 16px;
  }
</style>

<h1>Offline Brand Protection using NBT 2000 </h1>

<button id="scanButton">Scan/Read</button>


<script>
 
// Create a new instance of the NFC reader
const nfc = new NFC();


// Check if NFC is supported by the device
if ('NDEFReader' in window) {
  // Create a new instance of NDEFReader
  const ndef = new NDEFReader();

  // event listener to handle reading the NDEF content
  ndef.addEventListener('reading', event => {
    const message = event.message;

  });

  // Start reading the NFC card
  ndef.scan();
} else {
  console.log('NFC is not supported by this device.');
}


const scanButton = document.getElementById("scanButton");

  scanButton.addEventListener("click", async () => {
  log("User clicked scan button");

  try {
    const ndef = new NDEFReader();
    await ndef.scan();
    log("> Scan started");

    ndef.addEventListener("readingerror", () => {
      log("Cannot read data from the NFC tag. Try another one?");
    });

    ndef.addEventListener("reading", ({ message, serialNumber }) => {
      log(`> Serial Number: ${serialNumber}`);
      log(`> Records: (${message.records.length})`);
    });
  } catch (error) {
    log("error " + error);
  }
});

// Start the NFC reader
nfc.start();
const SmartCard = require('smartcard');
const crypto = require('crypto');

// Start listening for NFC events
nfc.on('reader', async (reader) => {
  
  // Wait for a card to be detected
  reader.on('card', async (card) => {
    console.log(`Card detected: ${card.uid}`);

    // Connect to the card
    await reader.connect({ card });

    // Send APDU commands to the card
    const apduCommands = 
      // APDU commands here  // Example: '00A4040007A000000003101000'
      array.forEach(element => 
      {
      const selectT4TFileCommand = [0x00, 0xA4, 0x00, 0x04, 0x00, 0x07, 0xA0, 0x00, 0x00, 0x00, 0x03, 0x10, 0x10, 0x00];
      const selectT4TFileResponse = card.transmit(selectT4TFileCommand);

      const selectCCFileCommand = [0x00, 0xA4, 0x00, 0x0C, 0x02, 0xE1, 0x03, 0x00];
      const selectCCFileResponse = card.transmit(selectCCFFileCommand);

      const readCCFileCommand = [0x00, 0xB0, 0x00, 0x00, 0x00];
      const readCCFileResponse = card.transmit(readNDEFFileCommand);

      const selectNDEFFileCommand = [0x00, 0xA4, 0x00, 0x0C, 0x02, 0xE1, 0x03, 0x00];
      const selectNDEFFileResponse = card.transmit(selectNDEFFileCommand);
      //Read the NDEF file
      const readNDEFFileCommand = [0x00, 0xB0, 0x00, 0x00, 0x00];
      const readNDEFFileResponse = card.transmit(readNDEFFileCommand);

      //verify certificate code
      
reader.onreading = async event => 
{
    try {
      // Read the NDEF message from the NFC tag
      const ndefFileData = readNDEFFileResponse;

      const message = await event.message.read();

      // Find the first record of type "application/x-x509-ca-cert"
      const certRecord = message.find(record => {
        const recordType = record.recordType[0];
        return recordType === 0x61 && record.typeNameFormat === 'mime' && record.type.includes('application/x-x509-ca-cert');
      });

      if (certRecord) {
        // Extract the certificate data from the record
        const certData = certRecord.data;

        // Convert the payload to a string
        const textDecoder = new TextDecoder();
        
        const text = textDecoder.decode(certData);

          // Log the decoded payload to the console
          console.log(text);

  
      } else {
        console.log('No certificate found');
      }
    } catch (error) {
      console.error(error);
    }
  };


// Load the root CA certificate
const rootCACertificate = "-----BEGIN CERTIFICATE-----MIIC4jCCAkSgAwIBAgIEEjRWeDAKBggqhkjOPQQDBDCBjTE1MDMGA1UEAwwsTkZDIGJyaWRnZSAmIENMIHRhZyBkZXZpY2VzIFRFU1Qgcm9vdCBDQSAxMDAxCzAJBgNVBAYTAkRFMSEwHwYDVQQKDBhJbmZpbmVvbiBUZWNobm9sb2dpZXMgQUcxJDAiBgNVBAsMG05GQyBicmlkZ2UgJiBDTCB0YWcgZGV2aWNlczAiGA8yMDIyMDgwMTAwMDAwMFoYDzIwNDcwNzMwMjM1OTU5WjCBljE+MDwGA1UEAww1TkZDIGJyaWRnZSAmIENMIHRhZyBkZXZpY2VzIFRFU1QgbWFudWZhY3R1cmluZyBDQSAxMDAxCzAJBgNVBAYTAkRFMSEwHwYDVQQKDBhJbmZpbmVvbiBUZWNobm9sb2dpZXMgQUcxJDAiBgNVBAsMG05GQyBicmlkZ2UgJiBDTCB0YWcgZGV2aWNlczB2MBAGByqGSM49AgEGBSuBBAAiA2IABJfDB2SSZWUsYOtgzTLTx0cUf8pItX9VWG5CUuDqUFzURrZAgYgEwFXhhezLlD6+3PIs/KjroZfEPq3lWSB+rEap52SDgl6+cXz+VZGTe5ZohqIpeL8rSmVFuqNU4j3m5qNmMGQwEgYDVR0TAQH/BAgwBgEB/wIBADAfBgNVHSMEGDAWgBRri56q9lShLYPwrDtOmHWWLLW6AzAOBgNVHQ8BAf8EBAMCAgQwHQYDVR0OBBYEFGf68zcpG71hz1h5qJSXHcYydvMPMAoGCCqGSM49BAMEA4GLADCBhwJCAPADMT+Z5pDS4VNCNeIHfSgOv8pIPojYYlLPVnqEwy6+yptS9GE1B8etWTC4NrjW8LqOlLtOGClfhp23OlCtY/QhAkFArkXEoEZFfMuuiGW+mcxYG0MMwjuyeGYi3mJBXb0i9Onc3bCbx/oJ16GrFijMUz9KooWdiUCi+khHwNqrKJQ3ag==-----END CERTIFICATE-----";
{
//Signature Algorithm: (ecdsa-with-SHA256) ;
issuer: 'CN=NFC bridge & CL tag devices TEST manufacturing CA 100, C=DE, O=Infineon Technologies AG, OU=NFC bridge & CL tag devices' ;
validFrom: '2022-08-01';
validTo: '2042-07-30';

}

function isDateValid(date) {
  const currentDate = new Date();
  const validFromDate = new Date(certData.validFrom);
  const validToDate = new Date(certData.validTo);

  return currentDate >= validFromDate && currentDate <= validToDate;
}

//const certificateDate = new Date('currentDate');
console.log(isDateValid(certificateDate));


// convert to binary format
const binaryData = Buffer.from(rootCACertificate, 'utf-8');

// encode to base64 format
const base64Data = binaryData.toString('base64');

//console.log(base64Data);
const inputArray = new Uint8Array(base64Data);

//const cert = generateCertificate(certOptions);

// Parse the certificate and get the public key
const certObject = forge.pki.certificateFromPem(cert);
const publicKey = certObject.publicKey;

// Verify the certificate of the binary-encoded data using the certificate public key
const verified = publicKey.verify(inputArray,inputArraycert);

// If the certificate is valid, then the input byte stream data matches the certificate
if (verified) {
  console.log('Validation succeeded');
} else {
  console.log('Validation failed');
}  

// Print the verification result
console.log(`Certificate verification result: ${isVerified}`);


}) ;
// authenticate tag (1-255) byte challenge)

const CMD_AUTHENTICATE_TAG = [0x00, 0x88, 0x00, 0x00, 0x08];

// Generate a random 8-byte data challenge
const dataChallenge = crypto.randomBytes(8);

const reader = new SmartCard.Reader();

reader.on('card', async (card) => {
  try {
    // Send the authenticate tag APDU command
    const authTagApdu = Buffer.from(CMD_AUTHENTICATE_TAG.concat(dataChallenge));
    const authTagResponse = await card.sendApdu(authTagApdu);

    // Extract the signature from the response
    const signature = authTagResponse.subarray(authTagResponse.length - 64, authTagResponse.length);

    //  Infineon key
    const key = Buffer.from('key', 'hex');

    // Compute the hash of the challenge and key using SHA-256
    const hash = crypto.createHash('sha256');
    hash.update(Buffer.concat([Buffer.from(dataChallenge), key]));
    const challengeHash = hash.digest();

    // Verify the signature using the challenge hash and the Infineon key
    const verify = crypto.createVerify('ecdsa-with-SHA256');
    verify.update(Buffer.from(dataChallenge));
    const isVerifiedsignature = verify.verify(key, signature);

    console.log(`Signature: ${signature.toString('hex')}`);
    console.log(`Verified: ${isVerifiedsignature}`);

  } catch (error) {
    console.error(`Error: ${error}`);
  } 
});

  for (const command of apduCommands)
  {
    try {
        // Send the command to the card
        const response = await reader.transmit(Buffer.from(command, 'hex'));
        console.log(`Command: ${command}`);
        console.log(`Response: ${response.toString('hex')}`);
      } catch (error) {
        console.error(`Error sending command: ${command}`);
        console.error(error);
      }
    }

    // Disconnect from the card
    await reader.disconnect();
    console.log(`Card disconnected: ${card.uid}`);

  });

  // Wait for the reader to be removed
  reader.on('end', () => {
    console.log(`NFC reader removed: ${reader.reader.name}`);
  });
  
});



function logCommand(command) {
  var commandLog = document.getElementById("commandLog");
  commandLog.innerHTML += command + "<br>";
  commandLog.scrollTop = commandLog.scrollHeight;

}

logCommand("Reading NFC NDEF message...");

</script> 

